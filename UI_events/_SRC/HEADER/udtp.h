#ifndef __IP17__
#define __IP17__

#pragma comment (lib, "ws2_32.lib")
#include <winsock2.h>
#include <windows.h>
#include <ws2tcpip.h>

typedef unsigned int uint32;
typedef unsigned long uint64;

#define IPPROTO_IP17 10



typedef struct udtp_Connection UDTP_CONNECTION;
struct udtp_workingtread;

struct NetID{


};


//Структура IP пакетов версии 4 
struct ip_header_v4 {
	/** Первые 4 бита vhl - это версия. Для IPv4 значение поля должно быть равно 4.
	 *	Вторые 4 бита vhl - это IHL. IHL — (Internet Header Length) длина заголовка IP-пакета в 32-битных словах (dword). 
	 *	Именно это поле указывает на начало блока данных в пакете. Минимальное корректное значение для этого поля равно 5.
	*/
	unsigned char   vhl;
		#define IP_V  (ip)  (((ip) -> vhl & 0xf0) >> 4)
		#define IP_HL (ip)  ((ip) -> vhl & 0x0f)

	/**Тип обслуживания (Type of Service, акроним TOS) — байт, содержащий набор критериев, определяющих тип обслуживания IP-пакетов.
	*	Описание байта обслуживания побитно :
	*		0 - 2 — приоритет(precedence) данного IP - сегмента
	*	3 — требование ко времени задержки(delay) передачи IP - сегмента(0 — нормальная, 1 — низкая задержка)
	*	4 — требование к пропускной способности(throughput) маршрута, по которому должен отправляться IP - сегмент(0 — низкая, 1 — высокая пропускная способность)
	*	5 — требование к надежности(reliability) передачи IP - сегмента(0 — нормальная, 1 — высокая надежность)
	*	6 - 7 — ECN — явное сообщение о задержке(управление IP - потоком).
	*/
	unsigned char  type_of_service;

	//.Длина пакета - длина пакета в октетах, включая заголовок и данные. Минимальное корректное значение для этого поля равно 20, максимальное 65535.
	unsigned short total_length;

	/** Идентификатор — значение, назначаемое отправителем пакета и предназначенное
	*	для определения корректной последовательности фрагментов при сборке пакета.
	*	Для фрагментированного пакета все фрагменты имеют одинаковый идентификатор.
	*/
	unsigned short id;

	//3 бита флагов. Первый бит должен быть всегда равен нулю, 
	//второй бит DF (don’t fragment) определяет возможность фрагментации пакета и 
	//третий бит MF (more fragments) показывает, не является ли этот пакет последним в цепочке пакетов.
	//Оставшиеся 13 бит смещение фрагмента.
	//Смещение фрагмента — значение, определяющее позицию фрагмента в потоке данных.
	//Смещение задается количеством восьми байтовых блоков, поэтому это значение требует умножения на 8 для перевода в байты.
	unsigned short frame_offset;
		#define IP_DF (ip)  ((ip) -> frame_offset & 0x4000)        /* dont fragment flag */
		#define IP_MF (ip)  ((ip) -> frame_offset & 0x2000)        /* more fragments flag */
		#define IP_OFFMASK (ip)  ((ip) -> frame_offset & 0x1fff)   /* mask for fragmenting bits */

	//Однобайтовое поле, заполняемое создающим IP-сегмент узлом сети количеством единиц времени жизни IP-сегмента в сети. 
	//RFC 791 специфицирует в качестве этих единиц секунды и требует, чтобы каждый транзитный узел сети, 
	//через который проходит IP-сегмент, уменьшал содержимое этого поля по крайней мере на 1 
	//(даже при условии, что обработка сегмента на самом деле заняла меньше одной секунды). 
	//Таким образом, на практике, время жизни (TTL - Time To Live) - это максимальное количество узлов,
	//которое может пройти до своего уничтожения IP-сегмент.
	//Каждый IP - модуль на любом узле сети обязан уничтожать IP - сегменты, 
	//для которых поле "время жизни" стало равным нулю.Этим предотвращается появление в сети IP - сегментов, 
	//"блуждающих" по ней бесконечное время.При этом узлу - источнику уничтоженного IP - сегмента посылается ICMP - сегмент, извещающий об этом событии.
	//В UNIX - реализациях, как правило, это поле заполняется источником IP - сегмента числом из диапазона 15...30.
	unsigned char  time_to_live;

	//Транспорт
	//Поле размером в байт, содержащее идентификатор протокола более высокого(обычно, транспортного) уровня, для которого предназначены данные IP - сегмента.Ниже приведены идентификаторы для ряда протоколов.
	//		-------- + ------------ - +------------------------------------------
	//		Иденти - : Сокращенное : Имя протокола
	//		 фикатор : название :
	//		-------- + ------------ - +------------------------------------------
	//		  1        ICMP					Межсетевой протокол управляющих сообщений
	//		  2        IGMP					Межсетевой протокол группового управления
	//		  3        GGP					Протокол "шлюз-шлюз"
	//		  6        TCP					Протокол управления передачей
	//		  8        EGP					Протокол "внешних" шлюзов
	//		  17       UDP					Протокол дейтаграмм пользователя
	//		  27       RDP					Протокол надежных данных
	//		  28       IRTP					Протокол межсетевой надежной передачи
	//		  29       ISO TP4				Транспортный протокол ISO 4 класса
	//		  80       ISO IP				Межсетевой протокол ISO
	//		  89       OSPF					Протокол "кратчайший путь первым"
	//		------ - +------------- - +------------------------------------------
	unsigned char  protocol;
			#define ICMP (pr)  ((rp) -> protocol & 0x1)
			#define IGMP (pr)  ((rp) -> protocol & 0x2)
			#define GGP (pr)  ((rp) -> protocol & 0x3)
			#define TCP (pr)  ((rp) -> protocol & 0x6)
			#define EGP (pr)  ((rp) -> protocol & 0x8)
			#define UDP (pr)  ((rp) -> protocol & 0x11)
			#define RDP (pr)  ((rp) -> protocol & 0x1b)
			#define IRTP (pr)  ((rp) -> protocol & 0x1c)
			#define ISO_TP4 (pr)  ((rp) -> protocol & 0x1d)
			#define ISO_IP (pr)  ((rp) -> protocol & 0x50)
			#define OSPF (pr)  ((rp) -> protocol & 0x59)

	//Контрольная сумма заголовка
	//Двухбайтовое поле, содержащее контрольную сумму заголовка IP - сегмента
	//(обращаем внимание, что для данных IP - сегмента контрольная сумма не подсчитывается;
	//контролировать данные - задача протоколов транспортного уровня).
	//Поскольку заголовок IP - сегмента содержит поле "время жизни", изменяющее свое значение в каждом узле, 
	//через который следует IP - сегмент, то для вычисления контрольной суммы должен использоваться эффективный(а, следовательно, простой алгоритм).
	//Во всех протоколах, входящих в архитектуру TCP / IP, используется так называемая Internet - контрольная сумма, 
	//которая представляет собой дополнение 16 - битной суммы всех 16 - битных слов контролируемой информации.
	unsigned short checksum;

	struct  in_addr source_address, dest_address;
};

//Структура IP пакетов версии 6 
struct ip_header_v6 {
	// Первые 4 бита vtf -	это версия. Для IPv4 значение поля должно быть равно 6.
	// Следующие 8 бит vtf - Traffic Class или Приоритет – используется для того, чтобы различать пакеты с разными требованиями к доставке в реальном времени.
	//						приоритет пакета (8 бит). Это поле состоит из двух значений. 
	//						Старшие 6 бит используются DSCP для классификации пакетов. Оставшиеся два бита используются ECN для контроля перегрузки.
	// Оставшиеся 20 бит -	Flow Label или метка потока.Поток — это последовательность пакетов, посылаемых отправителем определённому адресату. 
	//						При этом предполагается, что все пакеты данного потока должны быть подвергнуты определённой обработке. 
	//						Характер данной обработки задаётся дополнительными заголовками. Метка потока присваивается узлом-отправителем путём генерации псевдослучайного 20-битного числа.
	unsigned int   vtf;
		#define IP_V  (ip)  (((ip) -> vtf & 0xf0 00 00 00) >> 28)
		#define IP_TC (ip)  (((ip) -> vtf & 0xf 00 00 00) >> 20)
		#define IP_TC (ip)  ((ip) -> vtf & 0xfffff)

	//Первые 16 бит pnh - Payload Length, в отличие от поля Total Length в протоколе IPv4 данное поле не включает фиксированный заголовок пакета (16 бит).
	//Следующие 8 бит pnh - Next Header,Next Header: задаёт тип расширенного заголовка (англ. IPv6 extension), 
	//						который идёт следующим. В последнем расширенном заголовке поле Next Header задаёт тип транспортного протокола (TCP, UDP и т. д.)
	//Оставшиеся 8 бит pnh - Hop Limit: аналог поля time to live в IPv4 (8 бит).
	unsigned int   pnh;

	char source_address[128];
	char dest_address[128];

};


typedef struct udtp_header{

	//Описание 2-х байт по битам
	//Type[3..0] – тип заголовка;
	//Conn[4..5](Connection) – тип соединения :
	//			0 – основное(перенос данных);
	//			1 – вспомогательное(перенос ошибочных данных);
	//			2 – контрольное(передача данных контроля);
	//			3 – служебное(передача данных о состоянии).
	//А([6]Acknowledgment) – ответ, принимает значения 0 / 1:
	//			0 – Отказ;
	//			1 – Подтверждение.
	//D[7](Delay) – управление задержкой, принимает значения 0 / 1:
	//			0 – отсутствует(передача не критична к задержкам);
	//			1 –в  пределах периода цикла(передача в «реальном» времени).
	//Command[8..11] – номер команды, зависит от типа заголовка :
	//			0 - 	Сброс;
	//			1 - Открыть канал;
	//			2 - Закрыть канал;
	//			3 - Восстановить канал;
	//			4 - Дополнить канал;
	//			5 - Установить соединение;
	//			6 - Освободить соединение;
	//			7 - 15 – зарезервировано;
	//Connection[12..15] – номер соединение.Протокол udtp предоставляет возможность открытия до 16 соединений одновременно.
	//AuthenticationID[16..31] - Зарезервированно 2 байта для Authentication ID
	unsigned int control;

	//Размерность поля «Size» 64 бита. 
	//Максимальное значение поля «Size» : 18 446 744 073 709 551 615 как(2 ^ 64 – 1) байт.
	//Поле «Size» определяет:
	//	В режиме файловой передачи - размер файла
	//	В режиме потоковой передачи - принимает максимальное значение.
	//	В режиме пакетной передачи - определяет размер пакета.
	//	В режиме передачи команд - задает значение команды.
	long long size;

	//Размерность поля «Global Label Flow» 64 бита. 
	//Максимальное значение поля «Global Label Flow» : 18 446 744 073 709 551 615 как(2 ^ 64 – 1).
	//Поле «Global Label Flow» определяет уникальную метку канала передачи. Вычисляется по полям:
	//	•	Area Address destination(Autonomous System(AS)
	//	•	Area Address source(Autonomous System(AS) | |
	//	•	Destination(Address[7..0] | Name(127..0) | Alias(115..0)
	//	•	Source(Address[7..0] | Name(127..0) | Alias(115..0)
	long long gfl;

	//Protocol [0..15] - Поле «Protocol» определяет номер протокола в соответствии с rfc1700.
	//Bit Rate [16..31] - BitRate – функция, вычисляющая значения скорости передачи в значениях длительности временного интервала в заданного субцикле. 
	unsigned int pbr;
		#define Protocol(pr) (((pr) -> pbr & 0xff ff 00 00) >> 16)
		#define BitRate(pr) (((pr) -> pbr & 0xff ff ))
	//Контрольная сумма
	//Проверочный код CRC-32 контролирует целостность передачи блоков данных.
	//32 - битовое поле, содержащее CRC - контрольную сумму, подсчитанную для всего кадра.
	//Минимальная длина Ethernet - кадра составляет 64 байта(512 бит).
	//Такое ограничение связано с тем, что контроль столкновений различных кадров в Ethernet - шине
	//согласно алгоритму CSMA / CD выполняется на интервале времени в 47 микросекунд.
	//За это время осуществляется передача 470 бит(при скорости 10 мегабит в секунду), так что 512 - это округление 470 до числа, являющегося степенью 2.
	//В ситуациях, когда длина данных, передаваемых в теле кадра, недостаточна для формирования
	//кадра длиной не менее 64 байтов, драйвер Ethernet - контроллера искусственно дополняет тело пакета до необходимой длины.
	//	Примечание.Интересно, что согласно стандарту IEEE 802.3 рассмотренное выше 16 - битовое поле типа кадра
	//	на самом деле является полем длины(в байтах) тела Ethernet - кадра.
	//	Для идентификации типа содержимого тела кадра предлагается использовать специальный протокол LLC
	//	(Logic Link Control - протокол управления логической связью), занимающий промежуточное положение между Ethernet и вышележащими протоколами.
	//	Однако протокол LLC в среде UNIX(а, значит, и в большинстве других ОС) реализован не был : стандартом "de facto" остаются спецификации RFC 894. 
	//	Хотя надо отметить, что выбор значений идентификаторов типа кадра(0x0800 и больше) 
	//	не исключает возможности использования этого поля одновременно и для идентификации типа, и для хранения длины тела кадра(максимум 1500).
	unsigned int crc;

} UDTP_Header, PUDTP_Header;

typedef struct TreadParams {
	PUDTP_Header	*pheader;
	PUDTP_Header	*pudtp_header;
} structTreadParams, *pstructTreadParams;

enum TreadType{
	data = 0,
	error,
	control,
	status
};

enum MODE{
	file = 0,
	stream,
	message,
	command
};

typedef uint32 BIT;
typedef uint32 FEC;
typedef uint32 SEC;
typedef uint32 BR;
typedef uint32 EVENT;
typedef uint32 ERR;

typedef struct udtp_workingtread{
	HANDLE WINAPI handle;
	unsigned short type;
	SOCKET assinedSck;
} UDTP_WTREAD, *PUDTP_WTREAD;

typedef struct udtp_Channel{
	NetID  netID;
	UDTP_CONNECTION* listConn[16];
	sockaddr_in addr;
	uint32 activeConn;
} UDTP_CHANEL, *PUDTP_CHANEL;

typedef struct udtp_Connection{
	PUDTP_CHANEL parent_Ch;
	UDTP_Header  header;
	PUDTP_WTREAD wt[4];
} UDTP_CONNECTION, *PUDTP_CONNECTION;

//Протокол udtp в данной реализации использует Socket-raw для примитивов, распределенных по следующим группам:
/** Функции управление полосой пропускания;
*/
/**
задать значение скорости передачи; */
uint32 udtp_BitRate(PUDTP_CONNECTION *conn);			//задать значение скорости передачи;
uint32 udtp_Delay(PUDTP_CONNECTION *conn);			//задать тип контроля значения задержки;
uint32 udtp_ControlBitRate(PUDTP_CONNECTION *conn);	//контроль скорости передачи;
//Управление сетевым идентификатором;
	//** Пока не используется и не реализован
	int udtp_NetID_Init();		//Загрузить NetID на сетевое устройство;
	int udtp_NetID_Del();		//Удалить NetID с сетевого устройства;
	int udtp_NetID_Authen();	//Подтвердить достоверность NetID;
	int udtp_NetID_Acct();		//Задать NetID получателя;
	int udtp_NetID_Contact();	//Обратиться к NetID получателя;
//Управление переносом данных;
	uint32 udtp_Chanel(UDTP_CHANEL *ch, sockaddr_in addr);	//создать канал связи;
	//uint32 udtp_Open(UDTP_CHANEL *ch);	//открыть канал;
	//uint32 udtp_Take(UDTP_CHANEL *ch);	//принять канал;
	uint32 udtp_ShutChanel(UDTP_CHANEL *ch);	//закрыть канал;
	//uint32 udtp_Restore(UDTP_CHANEL *ch);	//восстановить канал;
	uint32 udtp_Connect(UDTP_CHANEL *ch);	//установить соединение;
	uint32 udtp_Accept(UDTP_CHANEL *ch, PUDTP_CONNECTION *conn);	//принять соединение;
	uint32 udtp_Close(PUDTP_CHANEL *ch, PUDTP_CONNECTION *conn);	//освободить соединение;
	uint32 udtp_Send(PUDTP_CHANEL *ch, PUDTP_CONNECTION *conn);	//передать данные по соединению;
	uint32 udtp_Receive(PUDTP_CHANEL *ch, PUDTP_CONNECTION *conn);	//принять данные из соединения;
	uint32 udtp_Repeat(PUDTP_CHANEL *ch, PUDTP_CONNECTION *conn);	//повторить данные по соединению;
	uint32 udtp_Crypto(PUDTP_CHANEL *ch, PUDTP_CONNECTION *conn);	//включить / отключить шифрование передаваемых данных;
	uint32 udtp_FecDec(PUDTP_CHANEL *ch, PUDTP_CONNECTION *conn);	//включить / отключить помехозащитное кодирование данные.


#endif

